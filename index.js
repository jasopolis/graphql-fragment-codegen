#!/usr/bin/env node
import fs from 'fs'
import path from 'path'
import getStdin from 'get-stdin'
import { graphql, parse, buildASTSchema, getIntrospectionQuery } from 'graphql'

const log = (x) => (console.trace(x), x)

// Turns an array of objects into an object indexed by a given field.
function index(array, field) {
    const index = {}
    array.forEach((item) => {
        index[item[field]] = item
    })
    return index
}

function indentedLine(level) {
    let line = '\n'
    for (let i = 0; i < level; i++) {
        line += '  '
    }
    return line
}

async function introspect(schemaString) {
    const schema = buildASTSchema(parse(schemaString))
    return await graphql({ schema, source: getIntrospectionQuery() })
}

function makeFragments(schemaContents) {
    const schema = schemaContents.data.__schema
    // Create lookup table of object, union, and interface types to find possible fields/types
    const types = schema.types.filter(
        ({ kind, name }) =>
            (kind === 'OBJECT' || kind === 'UNION' || kind === 'INTERFACE') &&
            !name.startsWith('__') &&
            name !== schema.queryType.name &&
            name !== schema.mutationType.name &&
            name !== schema.subscriptionType.name
    )
    const typeLookupTable = index(types, 'name')

    // Create definitions
    const definitions = types
        .filter(
            ({ kind, name }) =>
                kind === 'OBJECT' &&
                !name.startsWith('__') &&
                name !== schema.queryType.name
        )
        .map((type) => {
            const { name, fields } = type
            return {
                name,
                fragment: `fragment ${name} on ${name} {
  ${fields
      .map((field) => printField(field, typeLookupTable))
      // Some fields should not have autogenerated fragments, ie. fields with arguments.
      // Filter those from the output by returning null from printField.
      .filter((field) => field != null)
      .join(indentedLine(1))}
}
`,
            }
        })
    return `// This file was auto-generated by graphql-fragment-codegen. Do not edit it by hand.
${definitions
    .map(
        ({ name, fragment }) => `
export const ${name} = \`${fragment}\`
`
    )
    .join('')}`
}

function printField(field, typeLookupTable, indent = 1) {
    const { name, type } = field
    if ('args' in field && field.args.length > 0) {
        return null
    }
    if (type.kind === 'SCALAR') {
        return name
    }
    if (type.kind === 'OBJECT') {
        // If current field is an object, lookup its own fields and recursively print those
        return (
            name +
            ' {' +
            indentedLine(indent + 1) +
            typeLookupTable[type.name].fields
                .map((field) => printField(field, typeLookupTable, indent + 1))
                .filter((field) => field != null)
                .join(indentedLine(indent + 1)) +
            indentedLine(indent) +
            '}'
        )
    }
    if (type.kind === 'UNION' || type.kind === 'INTERFACE') {
        // If current field is a union or interface, use inline fragments
        // to include fields from all possible types
        return (
            name +
            ' {' +
            indentedLine(indent + 1) +
            typeLookupTable[type.name].possibleTypes
                .map(
                    (possibleType) =>
                        '... on ' +
                        possibleType.name +
                        ' {' +
                        indentedLine(indent + 2) +
                        typeLookupTable[possibleType.name].fields
                            .map((field) =>
                                printField(field, typeLookupTable, indent + 2)
                            )
                            .filter((field) => field != null)
                            .join(indentedLine(indent + 2)) +
                        indentedLine(indent + 1) +
                        '}'
                )
                .join(indentedLine(indent + 1)) +
            indentedLine(indent) +
            '}'
        )
    }
    if (type.kind === 'NON_NULL' || type.kind === 'LIST') {
        return printField(
            { ...field, type: type.ofType },
            typeLookupTable,
            indent
        )
    }
    console.error('unmatched type kind: ', type.kind)
    return null
}

async function main() {
    const stdin = await getStdin()
    if (stdin === '') {
        process.exit(1)
    }
    const schemaContents = await introspect(stdin)
    process.stdout.write(makeFragments(schemaContents))
}
main()
